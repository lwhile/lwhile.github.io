<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    神蛋杂谈
</title>
<link rel="shortcut icon" href="https://lwhile.github.io/favicon.ico?v=1576339658449">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lwhile.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://lwhile.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://lwhile.github.io">
                <img class="avatar" src="https://lwhile.github.io/images/avatar.png?v=1576339658449" alt="">
            </a>
            <div class="site-title">
                <h1>
                    神蛋杂谈
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://lwhile.github.io/post/da-ge-xiao-qia">
                        打个小卡
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-12-15</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            今天领到我人生中的第八份工资，解决掉这个月信用卡的账单，第一次有了超过5位数的存款。
元旦那天，我在奇妙清单里写下了几个目标，其中最重要的一个是能够去陌生城市独立生存下来。三月份的时候，很幸运得到一个实习的机会。如我所愿，真的成了一名程序员。

接下来的那半年，每周要来回一次广州和肇庆，不断得平衡学校与公司之间的关系。入职的第一个星期，领导问我之前坚持过最久的一件事是什么，我说减肥。
这八个月中间心态确实有崩过，但最终还是坚持了下来，到了现在。
如果要问最近这一年我得到哪些成长，抛开我专业上的那些东西，我觉得最重要的，是将社会的模样从校园里面的那个轮廓，一天天得将细节渲染出来。见得越多，想要的越多，再看看自己有什么，心里就越来越恐慌，一点都不敢停下自己的脚步。
这周突然开始更新公众号，看到两年前自己推的那些东西，自己也会笑出来。大学终究还是在离我们远去，想起学校里面的生活，不由觉得大学生活真的是人生中最幸福的时光，怕是以后都不会有了。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://lwhile.github.io/post/da-ge-xiao-qia">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://lwhile.github.io/post/litter-memory-2017">
                        打个小卡
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-11-11</time>
                    
                </div>
                <div class="post-article">
                    
                        <a href="https://lwhile.github.io/post/litter-memory-2017" class="post-feature-image" style="background-image:url(https://lwhile.github.io/post-images/litter-memory-2017.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            今天领到我人生中的第八份工资，解决掉这个月信用卡的账单，第一次有了超过5位数的存款。
元旦那天，我在奇妙清单里写下了几个目标，其中最重要的一个是能够去陌生城市独立生存下来。三月份的时候，很幸运得到一个实习的机会。如我所愿，真的成了一名程序员。

接下来的那半年，每周要来回一次广州和肇庆，不断得平衡学校与公司之间的关系。入职的第一个星期，领导问我之前坚持过最久的一件事是什么，我说减肥。
这八个月中间心态确实有崩过，但最终还是坚持了下来，到了现在。
如果要问最近这一年我得到哪些成长，抛开我专业上的那些东西，我觉得最重要的，是将社会的模样从校园里面的那个轮廓，一天天得将细节渲染出来。见得越多，想要的越多，再看看自己有什么，心里就越来越恐慌，一点都不敢停下自己的脚步。
这周突然开始更新公众号，看到两年前自己推的那些东西，自己也会笑出来。大学终究还是在离我们远去，想起学校里面的生活，不由觉得大学生活真的是人生中最幸福的时光，怕是以后都不会有了。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://lwhile.github.io/post/litter-memory-2017">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://lwhile.github.io/post/for-developer">
                        致开发人员
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-11-06</time>
                    
                        <a href="https://lwhile.github.io/tag/GQVNWsaTp" class="post-tag i-tag
                            i-tag-success">
            #计算机
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://lwhile.github.io/post/for-developer" class="post-feature-image" style="background-image:url(https://lwhile.github.io/post-images/for-developer.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            「软技能:代码之外的生存指南」在开头部分有几句话,我看了之后觉得很棒,于是摘抄下来激励自己.

谨以本书献给所有自强不息,孜孜不倦地持续自我改进的开发人员,他们具备以下素质:
永远不会对&amp;quot;不错&amp;quot;感到心满意足
永远寻求每一个机会来扩展自己的视野, 探索未知事物
对知识的渴求永远不会熄灭
笃信软件开发并不仅仅意味着编写代码
知道失败不是结束,失败只是人生旅途上的小小一步
有过挣扎,有过失败,但仍然会爬起来继续战斗
拥有强烈意愿和决心,在人生的道路上不畏艰难
以及最重要的,愿意一路上帮助他人


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://lwhile.github.io/post/for-developer">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://lwhile.github.io/post/go-timezone">
                        Go 时区用法总结
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-02-19</time>
                    
                        <a href="https://lwhile.github.io/tag/GQVNWsaTp" class="post-tag i-tag
                            i-tag-other_4">
            #计算机
        </a>
                        
                        <a href="https://lwhile.github.io/tag/5UKnY2CH9d" class="post-tag i-tag
                            i-tag-error">
            #Go
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            坊间有个说法，说中美两国的程序员除了薪资、加班强度外，还有个比较有趣的差异，就是在编码时对于时区的敏感程度也不同。
「大部分」美国程序员在时区问题上很有经验，因为美国在日常生活中会使用到 3 个时区。而中国「大部分」程序员在编码时基本不会考虑时区问题，因为大家都在东八区，没那个烦恼。
在过去一年我维护着一个公司内部的日历库，用于做交易时间的计算。在这个过程中被时区问题折磨得很难受，不过也积累一些 Go 处理时区上的经验。
时区配置
时区的配置一定要声明在配置文件中，比如下面这种 yaml 格式：

timezone: Asia/Hong_Kong

别想着用机器时区一劳永逸这个问题，因为机器的变数太多了。
载入时区
在 Go 中，时区被封装在 time.Location 中进行抽象，而载入时区有两种方法

通过 IANA 数据库

给 time.LoadLocation 传入一个符合 IANA 时区数据库的时区名字，比如：

Asia/Hong_Kong


通过偏移量

time.FixedZone(&amp;quot;UTC-8&amp;quot;, -8 **60 **60)
转换时区
比较简单的操作，直接调一个 time struct instance 的 In(*Location) 方法。
修改时区
注意修改时区和转换时区是两种不同的概念。
比如北京时间 20:00pm 转换时区，以美东时区为例，会是 7:00am (冬令时)
而修改时区是指把北京 20:00pm 修改为美东 20:00pm，可以这样操作：

// Pseudo code
var estTime time.Time
var cstTime time.Time
var estTimezone *time.Location
// 通过 time.Date 方法重新生成一个 time struct instance
estTime := time.Date(cstTime.Year(), cstTime.Month(),..., estTimezone)

Round to day
实在想不起一个名词可以形容 Round to day 的过程，我们用这个方法来做日内时间的比较。
比较典型的应用场景是判断是否到了开市/休市时间。由于在 Go 中 time 类型是包含有年、月信息的，所以要表达「每天早上 9:30」 这个时间不大好做。
既然不好做，那就把它们去掉。

// Pseudo code
func RoundToDay(t time.Time) time.Time {
// 注意在 Go 中 zero time 并不是 0 year 0 month 0 day，而是 1，所以用 0 的话会溢出喔
return time.Date(1,1,t.Day(), t.Hour() ...)
}

LMT
LMT 这个问题是在 Round to day 上面引发出来的，说起来也很有趣。LMT 本意是指 local mean time（地方平时，在指定的经度范围内使用一致时间的地方太阳时）。
如果你用试图在 Go 里面用香港时区构建一个 zero time 的话，就会发现最后返回出来的 time struct instance 的 location 信息是 LMT。这个问题是在一处单元测试中发现的，死活无法通过测试（嗯，单测真的很重要）。
不过这是为什么？
我相信知道这个知识点的人绝对少之又少，这是一个非常非常冷的知识（最后通过我那位知识储备量非常丰富的同事知道的这个）

香港時間的授時服務，是香港天文台從1883年成立至今的主要職責。早期香港天文台使用赤道儀及中星儀，透過觀測星象測量時間。當時香港時間是當地平均時間（LMT）UTC+7:36:42（準確值為UTC+7:36:41.8842）。香港天文台最早於1885年1月1日對公眾授時[1]，當年香港天文台於九龍尖沙咀警署設置桅杆，以升降時間球的方式對外發布時間。1885年1月1日，香港天文台於中午12時50分把時間球升到桅杆頂端，然後於下午1時正，首次把時間球降下，成為香港首次報時訊號，並作為香港時間的標準。用於報時的時間球訊號塔，後來於1933年因為電台報時的開展而拆除。1904年10月30日，香港時間正式確定為格林威治標準時間快8小時（GMT+8）[2]。2004年，天文台安裝了一套高準確度授時系統，利用全球定位系統共視方法，向國際度量衡局提供天文台的原子鐘時間數據，參與訂定協調世界時。天文台亦根據國際度量衡局提供的時間數據調校原子鐘，使其準確度保持在一百萬分之一秒以內。現時，香港天文台以銫原子鐘報時系統作為香港時間的標準，誤差僅為每日1微秒之內。香港天文台設有互聯網時間伺服器，為互聯網的用戶提供準確的時間校正服務[3]。

根据上面的记录来看几个例子吧，首先是 1904 年 10 月 30 日后香港使用 GMT+8，我们把时间定格在它前一秒：

location, _ := time.LoadLocation(&amp;quot;Asia/Hong_Kong&amp;quot;)

t := time.Date(1904,10,29,11,59,59,59,location)
fmt.Println(t) // 1904-10-29 11:59:59.000000059 +0736 LMT &amp;lt;- LMT 无疑
然后是 1904 年 10 月 30 日 零点：

location, _ := time.LoadLocation(&amp;quot;Asia/Hong_Kong&amp;quot;)

t := time.Date(1904,10,30,0,0,0,0,location)
fmt.Println(t) // 1904-10-30 00:23:18 +0800 HKT &amp;lt;- HKT 了。
厉害吧。。。还有更厉害的。。。

location, _ := time.LoadLocation(&amp;quot;Asia/Hong_Kong&amp;quot;)

t := time.Date(1942,10,30,0,0,0,0,location)
fmt.Println(t) // 1942-10-30 00:00:00 +0900 JST
用 1942 年 10 月 30 日构建一个香港时间，时区会是（JST）日本标准时间。Why?
原因是这个：

香港日佔時期，又稱為香港日治時期或香港淪陷時期，是指第二次世界大戰時大日本帝國軍事占領香港的時期：由1941年12月25日香港總督楊慕琦投降起，至1945年8月15日日本無條件投降為止；香港人俗稱這段時期為「三年零八個月」。

别以为 Go 的开发团队这么有心，实际上 Go 也是读操作系统的 zoneinfo 文件。只能说在某个层面上操作系统也记录着每个地区的历史。。。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://lwhile.github.io/post/go-timezone">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://lwhile.github.io/post/exponential-backoff">
                        指数退避
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-04-02</time>
                    
                        <a href="https://lwhile.github.io/tag/GQVNWsaTp" class="post-tag i-tag
                            i-tag-banana">
            #计算机
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            这是加入新公司后的第一篇技术博文，主角是一种叫做指数退避的算法。还是按照以往的惯例，这篇文章会从问题的发生至问题的解决记一个流水账。
问题的场景发生业务系统中的 RPC 调用中，需求是希望如果一个 RPC 调用失败了，能够进行重试。
作为一个菜鸟，我很快写入了第一个版本，用 Go 语言描述出来的逻辑如下：
func retry(maxRetry int, f func() error) {
    for i:=0;i&amp;lt;maxRetry;i++ {
        err := f()
        if err == nil {
          return 
        }
    }
}

很快这种代码在 review 的时候就被打下来了。理由是作为网络调用，这种重试机制是不合理的。试想以下如果是遇到机器重启或者网络抖动，对方的服务要在 1 分钟甚至更久之后才能恢复正常，那么将重试放在一个没有停歇的 for 循环里面，试错的机会很快就会被用完。
mentor 提示我可以试下指数退避算法（exponential backoff），网上看了一些算法的介绍，很快就写了第二个版本出来。
逻辑还是差不多，只不过多了一步休眠的操作：
func retry(maxRetry int, f func() error) {
    for i:=0;i&amp;lt;maxRetry;i++ {
        err := f()
        if err == nil {
          return 
        }
        // calculate the dynamic duration
        dur := call()

        time.Sleep(dur)
    }
}

算法的核心在于计算出重试的间隔，如果重试失败，那么就要相应得延长下次重试的时间。
重试间隔计算公式如下：
sleep = min(cap, base * 2 ** attempt)
随着重试次数 attempt 的增加，sleep 的数值会出现指数级的变化。
对于一些服务比如涉及到事务的数据库操作，如果有多个 client 同时使用上面这条公式的话，会出现请求挤压的情况导致系统的整体吞吐量下降，这时候我们可以引入一个随机因子避免该问题，经过修改的公式如下：
sleep = random_between(0, min(cap, base * 2 ** attempt))
如果你使用的是Go，推荐下这个库：https://github.com/cenkalti/backoff

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://lwhile.github.io/post/exponential-backoff">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://lwhile.github.io/post/etcd-watch-source-code">
                        Etcd watch源码阅读
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2017-11-10</time>
                    
                        <a href="https://lwhile.github.io/tag/iYb5jfiTB" class="post-tag i-tag
                            i-tag-success">
            #etcd
        </a>
                        
                        <a href="https://lwhile.github.io/tag/GQVNWsaTp" class="post-tag i-tag
                            i-tag-error">
            #计算机
        </a>
                        
                        <a href="https://lwhile.github.io/tag/5UKnY2CH9d" class="post-tag i-tag
                            i-tag-other_4">
            #Go
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            公司的业务里面使用了Consul做服务发现, 发现其有一个watch机制.这个watch机制引起我的好奇, 因为刚好在看Etcd-raft的代码, Etcd也有类似的watch机制, 所以趁热打铁, 赶紧趁周末研究下etcd watch机制源码的实现.
在看源码之前, 我们通过一个简单的例子, 看看Etcd的watch是如何使用的.

先往Etcd写入一对KV


curl http://127.0.0.1:2379/v2/keys/name -XPUT -d value=&amp;quot;神蛋使者&amp;quot;


Watch这对KV


curl http://127.0.0.1:2379/v2/keys/name?wait=true

如果一切正常, 这时候请求会被阻塞住.

新开一个终端, 修改存进去的KV


curl http://127.0.0.1:2379/v2/keys/name -XPUT -d value=神蛋使者1号


阻塞的那个请求返回watch到的结果

{
  &amp;quot;action&amp;quot;:&amp;quot;set&amp;quot;,
  &amp;quot;node&amp;quot;:{ 
      &amp;quot;key&amp;quot;:&amp;quot;/name&amp;quot;,
      &amp;quot;value&amp;quot;:&amp;quot;神蛋使者1号&amp;quot;,
      &amp;quot;modifiedIndex&amp;quot;:25,
     &amp;quot;createdIndex&amp;quot;:25
  },
   &amp;quot;prevNode&amp;quot;: {
     &amp;quot;key&amp;quot;:&amp;quot;/name&amp;quot;,
     &amp;quot;value&amp;quot;:&amp;quot;神蛋使者&amp;quot;,
     &amp;quot;modifiedIndex&amp;quot;:24,
     &amp;quot;createdIndex&amp;quot;:24
   }
  }

体验流程大概就是这样, 下面正式看源码.
接口定义
type Watcher interface {
	// Watch watches on a key or prefix. The watched events will be returned
	// through the returned channel.
	// If the watch is slow or the required rev is compacted, the watch request
	// might be canceled from the server-side and the chan will be closed.
	// &#39;opts&#39; can be: &#39;WithRev&#39; and/or &#39;WithPrefix&#39;.
	Watch(ctx context.Context, key string, opts ...OpOption) WatchChan

	// Close closes the watcher and cancels all watch requests.
	Close() error
}

该接口定义了两个方法, Watch 和 Close
Watch 方法返回一个WatchChan 类似的变量, WatchChan是一个channel, 定义如下:
type WatchChan &amp;lt;-chan WatchResponse

该通道传递WatchResponse类型
type WatchResponse struct {
	Header pb.ResponseHeader
	Events []*Event

	// CompactRevision is the minimum revision the watcher may receive.
	CompactRevision int64

	// Canceled is used to indicate watch failure.
	// If the watch failed and the stream was about to close, before the channel is closed,
	// the channel sends a final response that has Canceled set to true with a non-nil Err().
	Canceled bool

	// Created is used to indicate the creation of the watcher.
	Created bool

	closeErr error
}

其中Event类型是一个gRPC生成的消息对象
type Event struct {
	// type is the kind of event. If type is a PUT, it indicates
	// new data has been stored to the key. If type is a DELETE,
	// it indicates the key was deleted.
	Type Event_EventType `protobuf:&amp;quot;varint,1,opt,name=type,proto3,enum=mvccpb.Event_EventType&amp;quot; json:&amp;quot;type,omitempty&amp;quot;`
	// kv holds the KeyValue for the event.
	// A PUT event contains current kv pair.
	// A PUT event with kv.Version=1 indicates the creation of a key.
	// A DELETE/EXPIRE event contains the deleted key with
	// its modification revision set to the revision of deletion.
	Kv *KeyValue `protobuf:&amp;quot;bytes,2,opt,name=kv&amp;quot; json:&amp;quot;kv,omitempty&amp;quot;`
	// prev_kv holds the key-value pair before the event happens.
	PrevKv *KeyValue `protobuf:&amp;quot;bytes,3,opt,name=prev_kv,json=prevKv&amp;quot; json:&amp;quot;prev_kv,omitempty&amp;quot;`
}

接下来看实现了Watcher接口的watcher类型
// watcher implements the Watcher interface
type watcher struct {
	remote pb.WatchClient

	// mu protects the grpc streams map
	mu sync.RWMutex

	// streams holds all the active grpc streams keyed by ctx value.
	streams map[string]*watchGrpcStream
}

watcher结构很简单, 只有3个字段. remote抽象了发起watch请求的客户端, streams是一个map, 这个map映射了交互的数据流.还有一个保护并发环境下数据流读写安全的读写锁.
streams所属的watchGrpcStream类型抽象了所有交互的数据, 它的结构定义如下:
type watchGrpcStream struct {
	owner  *watcher
	remote pb.WatchClient

	// ctx controls internal remote.Watch requests
	ctx context.Context
	// ctxKey is the key used when looking up this stream&#39;s context
	ctxKey string
	cancel context.CancelFunc

	// substreams holds all active watchers on this grpc stream
	substreams map[int64]*watcherStream
	// resuming holds all resuming watchers on this grpc stream
	resuming []*watcherStream

	// reqc sends a watch request from Watch() to the main goroutine
	reqc chan *watchRequest
	// respc receives data from the watch client
	respc chan *pb.WatchResponse
	// donec closes to broadcast shutdown
	donec chan struct{}
	// errc transmits errors from grpc Recv to the watch stream reconn logic
	errc chan error
	// closingc gets the watcherStream of closing watchers
	closingc chan *watcherStream
	// wg is Done when all substream goroutines have exited
	wg sync.WaitGroup

	// resumec closes to signal that all substreams should begin resuming
	resumec chan struct{}
	// closeErr is the error that closed the watch stream
	closeErr error
}

比较有意思的是, watchGrpcStream也包含了一个watcher类型的owner字段, watcher和watchGrpcStream可以互相引用到对方.同时又定义了watcher类型中已经定义过的remote,而且还不是指针类型, 这点不大明白作用是啥.
还有几个字段值得关注, 一个是substreams, 看下它的定义和注释:
// substreams holds all active watchers on this grpc stream
substreams map[int64]*watcherStream

再看看watcherStream类型的定义:
// watcherStream represents a registered watcher
type watcherStream struct {
	// initReq is the request that initiated this request
	initReq watchRequest

	// outc publishes watch responses to subscriber
	outc chan WatchResponse
	// recvc buffers watch responses before publishing
	recvc chan *WatchResponse
	// donec closes when the watcherStream goroutine stops.
	donec chan struct{}
	// closing is set to true when stream should be scheduled to shutdown.
	closing bool
	// id is the registered watch id on the grpc stream
	id int64

	// buf holds all events received from etcd but not yet consumed by the client
	buf []*WatchResponse
}

画个图整理下他们之间的关系:

接下来轮到watcher是如何watch方法的了:
// Watch posts a watch request to run() and waits for a new watcher channel
func (w *watcher) Watch(ctx context.Context, key string, opts ...OpOption) WatchChan {
	// 应用配置
	ow := opWatch(key, opts...)

	var filters []pb.WatchCreateRequest_FilterType
	if ow.filterPut {
		filters = append(filters, pb.WatchCreateRequest_NOPUT)
	}
	if ow.filterDelete {
		filters = append(filters, pb.WatchCreateRequest_NODELETE)
	}

	// 根据传入的参数构造watch请求
	wr := &amp;amp;watchRequest{
		ctx:            ctx,
		createdNotify:  ow.createdNotify,
		key:            string(ow.key),
		end:            string(ow.end),
		rev:            ow.rev,
		progressNotify: ow.progressNotify,
		filters:        filters,
		prevKV:         ow.prevKV,
		retc:           make(chan chan WatchResponse, 1),
	}

	ok := false
	// 将请求上下文格式化为字符串
	ctxKey := fmt.Sprintf(&amp;quot;%v&amp;quot;, ctx)

	// find or allocate appropriate grpc watch stream
	// 接下来配置对应的输出流, 注意得加锁
	w.mu.Lock()

	// 如果stream为空, 返回一个已经关闭的channel.
	// 这种情况应该是防止streams为空的情况
	if w.streams == nil {
		// closed
		w.mu.Unlock()
		ch := make(chan WatchResponse)
		close(ch)
		return ch
	}

	// 注意这里, 前面我们提到streams是一个map,该map的key是请求上下文
	// 如果该请求对应的流为空,则新建
	wgs := w.streams[ctxKey]
	if wgs == nil {
		wgs = w.newWatcherGrpcStream(ctx)
		w.streams[ctxKey] = wgs
	}
	donec := wgs.donec
	reqc := wgs.reqc
	w.mu.Unlock()

	// couldn&#39;t create channel; return closed channel
        // couldn&#39;t create channel; return closed channel
	// 这里要设置为缓冲的原因可能与下面的两个
	// closeCh &amp;lt;- WatchResponse{closeErr: wgs.closeErr}
	// 语句有关,这里不理解
	closeCh := make(chan WatchResponse, 1)

	// submit request
	select {
	// 发送上面构造好的watch请求给对应的流
	case reqc &amp;lt;- wr:
		ok = true
	// 请求断开(这里应该囊括了客户端请求断开的所有情况)
	case &amp;lt;-wr.ctx.Done():
	// watch完成
	// 这里应该是处理非正常完成的情况
	// 注意下面的重试逻辑
	case &amp;lt;-donec:
		if wgs.closeErr != nil {
			// 如果不是空上下文导致流被丢弃的情况
			// 则不应该重试
			closeCh &amp;lt;- WatchResponse{closeErr: wgs.closeErr}
			break
		}
		// retry; may have dropped stream from no ctxs
		return w.Watch(ctx, key, opts...)
	}

	// receive channel
	// 如果是初始请求顺利发送才会执行这里
	if ok {
		select {
		case ret := &amp;lt;-wr.retc:
			return ret
		case &amp;lt;-ctx.Done():
		case &amp;lt;-donec:
			if wgs.closeErr != nil {
				closeCh &amp;lt;- WatchResponse{closeErr: wgs.closeErr}
				break
			}
			// retry; may have dropped stream from no ctxs
			return w.Watch(ctx, key, opts...)
		}
	}

	close(closeCh)
	return closeCh
}

还有Watcher接口的另一个方法Close:
func (w *watcher) Close() (err error) {
	// 在锁内先将streams字段置为空
	// 在锁外再将一个个流都关闭
	// 这样做的意义在于不管哪个流关闭失败了
	// 都能先保证streams与这些流的关系被切断
	w.mu.Lock()
	streams := w.streams
	w.streams = nil
	w.mu.Unlock()
	for _, wgs := range streams {
		if werr := wgs.Close(); werr != nil {
			err = werr
		}
	}
	// etcd竟然也只是返回一个error
	// 虽然上面的for循环可能产生多个error
	return err
}

这样watcher就实现了Watcher接口.大致的实现思路本文就介绍到这里,剩下的代码也都是对其他相关数据结构的逻辑包装操作.
简单阅读Etcd的这一小部分源码下来, 我看到他们源码中的两个东西,算是Golang或者编程上面的一些最佳实践:


对包外只暴露一个公共接口, 包内的结构体实现该接口即可.就像本文中的Watcher接口和watcher结构体.这样有两个好处, 一个就是代码能够解耦,还有就是可以省去命名的苦恼(__)


另一个是注释的书写方式,我发现etcd源码里的注释很大一部分写在变量的定义上面,而且变量的定义名都很清晰.


抽象得体.这个其实不只是Etcd, 其他任何优秀的开源作品都把他们的代码抽象得很到位.突然想起我写的那些渣渣代码%&amp;gt;_&amp;lt;%


最后, 总结下etcd的watch机制.其实归根结底, 它的watch是通过gRPC的多路复用实现的,这是一个基于HTTP/2的特性.所以本文可能有些偏离了主题,探讨Etcd的watch机制, 其实应该研究HTTP/2才是.
算是给自己挖个坑.

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://lwhile.github.io/post/etcd-watch-source-code">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://lwhile.github.io/post/hi-openresty">
                        使用Openresty构建认证网关
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2017-11-07</time>
                    
                        <a href="https://lwhile.github.io/tag/s2UnbI257" class="post-tag i-tag
                            i-tag-other_4">
            #openresty
        </a>
                        
                        <a href="https://lwhile.github.io/tag/94Hr92W69j" class="post-tag i-tag
                            i-tag-info">
            #网络
        </a>
                        
                        <a href="https://lwhile.github.io/tag/GQVNWsaTp" class="post-tag i-tag
                            i-tag-other_3">
            #计算机
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            在单体应用中, 我们可以通过 cookie + session, 或者 JSON web token, 将认证逻辑在单体应用中实现, 简单高效, 还特别省事.
然而这几年随着服务化潮流越来越火(我觉得这是必然趋势, 想想我们人类社会是如何运作的), 很多以前单体应用不存在的问题, 现在已成为对单体应用拆分过程中的第一个障碍, 比如系统的认证体系.
如果每个拆出来的服务都要做一次认证(就是程序员多写几份认证的代码啦), 对于有理想有追求的灵魂の码农来说, 是绝对无法接受的.你说认证代码copy就好了, 不用重新写.no no no, 这样搞出来的架构不仅看着别扭, 代码闻着就觉得臭, 而且迟早有一天会出问题.
解决单体应用拆分服务后的认证问题其实很常规, 回想下祖师爷们帮我们总结的一句话: &amp;quot;Any problem in computer science can be solved by another layer of indirection.&amp;quot; 我们可以在所有服务前面增加一层认证服务.

看到认证服务这一层用来作为用户请求的总入口, 有Nginx或者Apache使用经验的同学自然而然就想到它们. 如果能把认证模块的功能整合进Nginx或者Apache这些Web服务器, 那岂不是更完美 ?
而这篇文章的主角: Openresty,就可以帮助我们简单快速得完成这个想法.这是一个由春哥(Github)发起的项目.你可以将Openresty看做Nginx + 常用模块构成的软件包, 但是最重要的功能是我们可以使用Lua在Nginx实现Web框架才能实现的逻辑, 接下来文章将会开始介绍如何使用Openresty, 将上面提到的认证服务整合进Nginx里.
安装
Openresty有两种安装方式, 一种是使用源码编译安装.一种使用官方提供的预编译包:
具体可参考官网的安装文档
Hello world
如果你没修改过Openresty的安装位置, 默认会被安装在/use/local/openresty目录下.我们现在可以尝试写一个Hello world级别的demo.
为Openresty创建工作目录并创建配置文件:

mkdir ~/openresty_work
cd ~/openresty_work
touch nginx.conf

接下来在nginx.conf里面配置一个路由规则
worker_processes 1;
error_log logs/error.log;

events {
	worker_connections 1024;
}

http {
	server {
		listen 8080;
		location /hello {
			default_type text/html;
			content_by_lua_block {
				ngx.say(&amp;quot;Hello Openresty.&amp;quot;)
			}			
		}
	}
}


跟普通的Nginx配置文件比起来, 上面的配置多了一个content_by_lua_block指令, 正是通过调用该指令, 访问该路由的时候,才会输出相应的内容.这个指令是由Openresty中的LuaNginxModule模块提供的功能, 请求进来的时候, Nginx会启动lua的虚拟机, 输出的内容则由lua提供.
我们可以使用content_by_lua_file指令替代content_by_lua_block, 将相关的lua代码写进文件里.
location /hello {
			content_by_lua_file lua/hello.lua;
		}


--- hello.lua
ngx.say(&amp;quot;Hello Openresty.&amp;quot;)

有了上面的铺垫,接下来可以开始构建我们的认证服务,认证的方式使用JWT
Openresty将一个请求的生命周期划分为4个阶段:

我们的认证服务将会挂载在第二阶段, 即 Rewrite/Access Phase 上.
接下来准备一个需要用到的库:
lua-resty-jwt
clone下来后放到hello.lua文件所在的文件夹,并将lua_package_path配置为:
lua_package_path &amp;quot;/root/openresty_work/lua/?.lua;/root/openresty_work/lua/lua-resty-jwt/lib/?.lua;;&amp;quot;;

构建的思路也很简单, 对用户提供一个登录请求, 验证身份后将jwt token分发给用户.用户接下来访问需要认证的接口, 则在header里面加入该token, 请求进入Openresty后由lua提取出token进行认证.
Nginx配置文件
server {
                listen 8080;
                location /hello {
                        content_by_lua_file lua/hello.lua;
                }
                location /login {
                        content_by_lua_file lua/sign.lua;
                }
                location /service1 {
                        access_by_lua_file lua/verify.lua;
                        # 需要反向代理在这配置
                }
                location /service {
                        access_by_lua_file lua/verify.lua;
                        # ...
                }
        }


下面是配置中相关的lua文件
sign.lua ↓:
local jwt = require &#39;resty.jwt&#39;

-- 只允许POST请求
if ngx.req.get_method() ~= &#39;POST&#39; then
    ngx.status = 405
    ngx.say(&amp;quot;Mehtod Not Allow&amp;quot;)
    return
end

-- 获取请求body
ngx.req.read_body()
local body_raw = ngx.req.get_body_data()
local body_json = cjson.decode(body_raw)
local username = body_json[&#39;username&#39;]
local password = body_json[&#39;password&#39;]

if not username or not password then
    ngx.log(ngx.ERR, username, password)
    ngx.status = 400
    ngx.say(&#39;无法获取账号或者密码&#39;)
    return
end

-- 验证账号和密码是否正确,如果验证失败则做如下处理
if not this_is_a_auth_method(username, password) then
    ngx.status = 401
    ngx.say(&#39;认证失败&#39;)
    return
end

verify.lua ↓:
local jwt = require &#39;resty.jwt&#39;

-- 从请求中提取header并从header从获取token字段
local headers = ngx.req.get_headers()
local token = headers[&#39;token&#39;]

-- 检查token是否存在
if not token then 
    ngx.status = 400
    ngx.say(&#39;无法获取token&#39;)
    return 
end 

-- 验证token
local jwt_obj = jwt:verify(vars.jwt_salt(), token)
if not jwt_obj[&#39;verified&#39;] then 
    ngx.status = 401
    ngx.say(&#39;无效的token&#39;)
    return 
end 

至此一个使用Openresty构建的认证网关的雏形已经出来了.需要说明的一句是, 上面的代码由于没有公司相关的运行环境,笔者没有经过测试和验证.所以只可阅读,不可复制后直接运行 😃
如果想把这套认证网关用在生产环境上, 还有很多东西需要考虑.比如跨域问题, 静态文件的代理问题等等.
个人接触Openresty的时间也不长, 文中难免会有地方写错了或者表达得很差, 欢迎发评论或者发邮件给我指正: lwhile521@gmail.com ,感谢.
对于Openresty, 个人认为要对它产生兴趣,关键在于认不认可让Nginx承担除了Web服务器之外更多的业务, 对于Openresty, 它能带来的好处有:


极致的性能.上文没有提到Openresty的性能, 其实Openresty的编程模型和NodeJS很像, 在Openresty的世界里面,所有东西都是非阻塞的,更难得可贵的是, 它不需要使用NodeJS中的回调函数, 代码写起来其实还是同步模型, 配合C语言编写的Nginx, 最快的脚本语言lua+luajit解释器,这套方案的性能无可挑剔了.


降低了Nginx模块的开发难度. Nginx + C/C++能做的, Openresty用lua都能做.开发效率高了, 性能还不怎么降, 何乐而不为呢?


参考资料


Openresty最佳实践
lua-resty-jwt



                                        </div>
                                        
                                            <a class="btn btn-text" href="https://lwhile.github.io/post/hi-openresty">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://lwhile.github.io/post/ri-zhi-qie-fen-wen-ti-you-gan">
                        日志切分问题有感
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2017-11-05</time>
                    
                        <a href="https://lwhile.github.io/tag/GQVNWsaTp" class="post-tag i-tag
                            i-tag-other_2">
            #计算机
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            有过服务端开发经验的同学应该对日志这个东西不陌生, 把程序丢到服务器上跑, 日志就是我们了解运行情况,甚至解BUG的唯一入口了.
有些程序的日志量会增长得非常快, 比如Nginx, 当一个日志文件大到几百MB甚至上GB的时候, 要从这个文件找出我们要的信息就基本等于大海捞针了,所以这时候对日志进行管理就显得格外重要.
日志量大的平台可以上ELK,利用ES的搜索优势基本不担心日志数据量大的问题.但本文不打算涉及这方面的内容.接下来主要讲讲如何正确得对日志文件做切分.
Linxu上的日志切分有两种形式, 一种是使用Linux的logrotate工具, 另外一种是使用额外编写的脚本, 这种形式一般是和日志库配合使用.
因为业务的关系, 我们最开始抛弃了使用logrotate的方案, 因为我们觉得这会给实施人员增加系统的的维护负担(后来发现是我们对logrotate不够了解).于是我们使用第二种方案, 将日志的切分操作在我们的日志库里面实现, 我们封装了logrus和lfshook, 利用logrus的hook机制将切分的逻辑嵌入在日志库里面,代码调用的时候会自动触发切分操作.我们会这样做也是受到beego框架的影响, 它的日志库默认就带了切分功能.
一切运作得很顺利, 直到我们有一次在使用Openresty的时候, 发现Nginx的日志没有被切分.因为之前使用Nginx的时候,默认安装完毕后日志是会自动以天切分的, 于是我们开始找Nginx的配置项,看看是否漏掉了某些配置.但是不找没关系,了解后才发现Nginx是不提供日志切分功能的.What ? 那之前的切分功能是怎么来的?
接下来解决问题的过程中发现了在/etc/logrotate.d/下有nginx的配置, 同时还有Mysql和其他基础组件的,这时我们才想到有可能是RPM包(我们的系统是Centos)安装的时候自动生成了一个logrotate的配置文件,后来一查果然是(命令:rpm -qpl xxx.rpm).而我们的Openresty包没有生成这个配置文件,所以导致Nginx的日志文件没有被切分.
实际上很多软件都只会做日志的记录,不会帮忙做切分,这个确实是合理的.这让我们想起logrus为什么不提供日志切分的功能,而是得由第三方的库去完成.我们将日志切分的逻辑耦合进代码里面,现在回过头来看其实也不是很合理,正确的做法其实还是应该在打RPM包的时候, 生成一个logrotate的配置文件, 这样一来也不会增加实施人员的负担,而且也可以将切分功能统一到一个地方去做.

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://lwhile.github.io/post/ri-zhi-qie-fen-wen-ti-you-gan">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://lwhile.github.io/images/avatar.png?v=1576339658449)">
        </div>
        <h1 class="id_card-title">
            神蛋杂谈
        </h1>
        <h2 class="id_card-description">
            
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lwhile.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>